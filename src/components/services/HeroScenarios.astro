---
// Section Hero avec design constellation organique
// 6 scénarios positionnés librement autour du hub central
// Lignes de connexion dynamiques + animations de flottement

import ScenarioNode from './ScenarioNode.astro';
import { scenarios } from '../../data/scenarios';
import logoSvg from '../../assets/logo.svg';

// Positions organiques pour la constellation (en %) - rapprochées du centre
const positions = [
  { top: '10%', left: '22%' },     // 0: Site obsolète (haut gauche)
  { top: '8%', right: '24%' },     // 1: Pas de présence (haut droite)
  { top: '42%', left: '12%' },     // 2: Outils désynchronisés (milieu gauche) - ajusté de 8% à 12%
  { top: '44%', right: '12%' },    // 3: Tâches chronophages (milieu droite) - ajusté de 6% à 12%
  { bottom: '10%', left: '24%' },  // 4: Idée à valider (bas gauche)
  { bottom: '8%', right: '22%' },  // 5: MVP urgent (bas droite)
];
---

<section class="hero-hub">
  <!-- Canvas pour les particules -->
  <canvas class="particles-canvas" id="particles-canvas"></canvas>

  <!-- Fond géométrique -->
  <div class="hero-bg">
    <div class="grid-pattern"></div>
    <div class="gradient-overlay"></div>
  </div>

  <!-- Contenu -->
  <div class="hero-content">
    <!-- Titre -->
    <header class="hero-header">
      <h1 class="hero-title">
        Quelle est ta
        <span class="title-highlight">situation</span> ?
      </h1>
      <p class="hero-subtitle">
        Clique sur ce qui te parle pour découvrir la solution.
      </p>
    </header>

    <!-- Constellation Layout -->
    <div class="constellation-container" id="hub-container">
      <!-- Lignes SVG dynamiques -->
      <svg class="connection-lines" id="connection-lines">
        <defs>
          <linearGradient id="line-grad-web" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#0096FF" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#0096FF" stop-opacity="0.3"/>
          </linearGradient>
          <linearGradient id="line-grad-auto" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#00D9A3" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#00D9A3" stop-opacity="0.3"/>
          </linearGradient>
          <linearGradient id="line-grad-validation" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#A300D9" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#A300D9" stop-opacity="0.3"/>
          </linearGradient>
          <filter id="glow-line">
            <feGaussianBlur stdDeviation="1.5" result="blur"/>
            <feMerge>
              <feMergeNode in="blur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
      </svg>

      <!-- Hub central -->
      <div class="hub-center" id="hub-center">
        <div class="hub-frame">
          <span class="hub-corner hub-corner-tl"></span>
          <span class="hub-corner hub-corner-tr"></span>
          <span class="hub-corner hub-corner-bl"></span>
          <span class="hub-corner hub-corner-br"></span>
        </div>
        <div class="hub-inner">
          <div class="hub-logo">
            <img src={logoSvg.src} alt="Jon Labs" />
          </div>
        </div>
        <div class="hub-pulse"></div>
      </div>

      <!-- 6 Nodes en constellation -->
      {scenarios.map((scenario, index) => (
        <div
          class="node-wrapper"
          data-node-index={index}
          data-pillar={scenario.pillar}
          style={`
            --appear-delay: ${0.3 + index * 0.1}s;
            --float-delay: ${index * 0.5}s;
            ${positions[index].top ? `top: ${positions[index].top};` : ''}
            ${positions[index].bottom ? `bottom: ${positions[index].bottom};` : ''}
            ${positions[index].left ? `left: ${positions[index].left};` : ''}
            ${positions[index].right ? `right: ${positions[index].right};` : ''}
          `}
        >
          <ScenarioNode
            title={scenario.title}
            subtitle={scenario.subtitle}
            scenarioId={scenario.id}
            service={scenario.pillar}
            position={index}
          />
        </div>
      ))}
    </div>

    <!-- Scroll indicator -->
    <div class="scroll-indicator">
      <span>Voir les détails</span>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 5v14M19 12l-7 7-7-7"/>
      </svg>
    </div>
  </div>
</section>

<style>
  .hero-hub {
    height: 100vh;
    height: 100dvh;
    min-height: 700px;
    position: relative;
    overflow: hidden;
    background: #0a0a0f;
    margin-top: -100px;  /* Remonter sous le header transparent */
  }

  /* Canvas particules */
  .particles-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    opacity: 0.6;
  }

  /* Fond géométrique */
  .hero-bg {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .grid-pattern {
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
    background-size: 50px 50px;
    mask-image: radial-gradient(ellipse at center, black 30%, transparent 80%);
  }

  .gradient-overlay {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(circle at 25% 25%, rgba(0, 150, 255, 0.06) 0%, transparent 40%),
      radial-gradient(circle at 75% 25%, rgba(0, 150, 255, 0.04) 0%, transparent 35%),
      radial-gradient(circle at 15% 50%, rgba(0, 217, 163, 0.06) 0%, transparent 40%),
      radial-gradient(circle at 85% 50%, rgba(0, 217, 163, 0.04) 0%, transparent 35%),
      radial-gradient(circle at 30% 80%, rgba(163, 0, 217, 0.06) 0%, transparent 40%),
      radial-gradient(circle at 70% 85%, rgba(163, 0, 217, 0.04) 0%, transparent 35%);
  }

  /* Contenu */
  .hero-content {
    position: relative;
    z-index: 1;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
    padding-top: 100px;
  }

  /* Header */
  .hero-header {
    text-align: center;
    margin-bottom: 1rem;
    padding-top: 2rem;
  }

  .hero-title {
    font-size: clamp(1.5rem, 3.5vw, 2.25rem);
    font-weight: 400;
    color: white;
    line-height: 1.2;
    margin: 0 0 0.5rem;
    letter-spacing: -0.02em;
  }

  .title-highlight {
    position: relative;
    color: #00D9A3;
  }

  .title-highlight::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: -2px;
    height: 2px;
    background: linear-gradient(90deg, transparent, #00D9A3, transparent);
  }

  .hero-subtitle {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.5);
    margin: 0;
  }

  /* Constellation Container */
  .constellation-container {
    position: relative;
    flex: 1;
    width: 100%;
    max-width: 1100px;
    min-height: 450px;
  }

  /* Connection lines SVG */
  .connection-lines {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: visible;
    opacity: 0;
    animation: linesReveal 0.5s ease-out 0.4s forwards;
  }

  @keyframes linesReveal {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .connection-lines line {
    stroke-width: 2;
    stroke-dasharray: 6 4;
    filter: url(#glow-line);
  }

  /* Hub center */
  .hub-center {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 130px;
    height: 130px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    animation: hubReveal 0.6s ease-out 0.2s forwards;
    z-index: 10;
  }

  @keyframes hubReveal {
    from {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.6);
    }
    to {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }

  .hub-frame {
    position: absolute;
    inset: 0;
    border: 1px solid rgba(255, 255, 255, 0.15);
  }

  .hub-corner {
    position: absolute;
    width: 18px;
    height: 18px;
    border-color: #00D9A3;
    border-style: solid;
  }

  .hub-corner-tl { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
  .hub-corner-tr { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
  .hub-corner-bl { bottom: -1px; left: -1px; border-width: 0 0 2px 2px; }
  .hub-corner-br { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }

  .hub-inner {
    position: relative;
    width: 100px;
    height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .hub-logo {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .hub-logo img {
    width: 80px;
    height: auto;
    filter: brightness(0) invert(1);
  }

  .hub-pulse {
    position: absolute;
    inset: -10px;
    border: 1px solid rgba(0, 217, 163, 0.3);
    animation: hubPulse 3s ease-in-out infinite;
  }

  @keyframes hubPulse {
    0%, 100% { opacity: 0.3; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.05); }
  }

  /* Node wrapper - positionnement absolu */
  .node-wrapper {
    position: absolute;
    opacity: 0;
    transform: translateY(20px);
    will-change: transform, opacity;
    animation: nodeAppear 0.5s ease-out forwards;
    animation-delay: var(--appear-delay, 0.3s);
    z-index: 5;
  }

  /* Float ajouté par JS après apparition */
  .node-wrapper.floating {
    opacity: 1;
    transform: translateY(0);
    animation: nodeFloat 4s ease-in-out infinite;
    animation-delay: var(--float-delay, 0s);
  }

  @keyframes nodeAppear {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes nodeFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  /* Scroll indicator */
  .scroll-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.4);
    font-size: 0.8rem;
    padding: 0.75rem;
    animation: bounce 2.5s infinite;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(5px); }
  }

  /* Responsive - Mobile */
  @media (max-width: 900px) {
    .hero-hub {
      min-height: auto;
    }

    .particles-canvas {
      display: none;
    }

    .hero-content {
      min-height: auto;
      padding: 3rem 1rem 2rem;
    }

    .hero-header {
      padding-top: 0;
    }

    .constellation-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      min-height: auto;
      padding: 1rem 0;
    }

    .connection-lines {
      display: none;
    }

    .hub-center {
      position: relative;
      top: auto;
      left: auto;
      transform: none;
      width: 90px;
      height: 90px;
      margin-bottom: 1rem;
      animation: hubRevealMobile 0.6s ease-out 0.2s forwards;
    }

    @keyframes hubRevealMobile {
      from { opacity: 0; transform: scale(0.6); }
      to { opacity: 1; transform: scale(1); }
    }

    .hub-inner {
      width: 70px;
      height: 70px;
    }

    .hub-logo img {
      width: 55px;
    }

    .hub-corner {
      width: 12px;
      height: 12px;
    }

    .node-wrapper {
      position: relative;
      top: auto !important;
      bottom: auto !important;
      left: auto !important;
      right: auto !important;
      width: 100%;
      max-width: 300px;
    }

    /* Pas de flottement sur mobile */
    .node-wrapper.floating {
      animation: none;
    }
  }

  /* Large screens */
  @media (min-width: 1400px) {
    .constellation-container {
      max-width: 1300px;
      min-height: 600px;
    }

    .hub-center {
      width: 160px;
      height: 160px;
    }

    .hub-inner {
      width: 125px;
      height: 125px;
    }

    .hub-logo img {
      width: 100px;
    }

    .hub-corner {
      width: 22px;
      height: 22px;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('hub-container');
    const svg = document.getElementById('connection-lines');
    const hubCenter = document.getElementById('hub-center');
    const nodes = document.querySelectorAll('.node-wrapper');
    const particlesCanvas = document.getElementById('particles-canvas') as HTMLCanvasElement;

    if (!container || !svg || !hubCenter) return;

    // ========================================
    // SYSTÈME DE PARTICULES
    // ========================================
    if (particlesCanvas && window.innerWidth > 768) {
      const ctx = particlesCanvas.getContext('2d');
      if (ctx) {
        const PARTICLE_COUNT = 25;
        const CONNECTION_DISTANCE = 100;
        const PARTICLE_SPEED = 0.3;

        const COLORS = [
          { r: 0, g: 150, b: 255 },   // Web (bleu)
          { r: 0, g: 217, b: 163 },   // Auto (vert)
          { r: 163, g: 0, b: 217 }    // Validation (violet)
        ];

        interface Particle {
          x: number;
          y: number;
          vx: number;
          vy: number;
          size: number;
          color: { r: number; g: number; b: number };
        }

        const particles: Particle[] = [];

        function resizeCanvas() {
          particlesCanvas.width = window.innerWidth;
          particlesCanvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          particles.push({
            x: Math.random() * particlesCanvas.width,
            y: Math.random() * particlesCanvas.height,
            vx: (Math.random() - 0.5) * PARTICLE_SPEED * 2,
            vy: (Math.random() - 0.5) * PARTICLE_SPEED * 2,
            size: 1.5 + Math.random() * 1.5,
            color: COLORS[i % 3]
          });
        }

        function animateParticles() {
          ctx!.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);

          particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > particlesCanvas.width) p.vx *= -1;
            if (p.y < 0 || p.y > particlesCanvas.height) p.vy *= -1;

            ctx!.beginPath();
            ctx!.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx!.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0.6)`;
            ctx!.fill();

            for (let j = i + 1; j < particles.length; j++) {
              const other = particles[j];
              const dx = p.x - other.x;
              const dy = p.y - other.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < CONNECTION_DISTANCE) {
                const opacity = (1 - distance / CONNECTION_DISTANCE) * 0.3;
                const avgR = Math.round((p.color.r + other.color.r) / 2);
                const avgG = Math.round((p.color.g + other.color.g) / 2);
                const avgB = Math.round((p.color.b + other.color.b) / 2);

                ctx!.beginPath();
                ctx!.moveTo(p.x, p.y);
                ctx!.lineTo(other.x, other.y);
                ctx!.strokeStyle = `rgba(${avgR}, ${avgG}, ${avgB}, ${opacity})`;
                ctx!.lineWidth = 1;
                ctx!.stroke();
              }
            }
          });

          requestAnimationFrame(animateParticles);
        }

        setTimeout(animateParticles, 100);
      }
    }

    // ========================================
    // LIGNES DE CONNEXION
    // ========================================
    const gradients: Record<string, string> = {
      'web': 'url(#line-grad-web)',
      'auto': 'url(#line-grad-auto)',
      'validation': 'url(#line-grad-validation)'
    };

    const lines: SVGLineElement[] = [];
    nodes.forEach((node, index) => {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      const pillar = node.getAttribute('data-pillar') || 'auto';
      line.setAttribute('stroke', gradients[pillar]);
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-dasharray', '6 4');
      line.setAttribute('filter', 'url(#glow-line)');
      line.style.animation = `lineFlow 1.8s linear infinite`;
      line.style.animationDelay = `${index * 0.15}s`;
      svg.appendChild(line);
      lines.push(line);
    });

    const style = document.createElement('style');
    style.textContent = `
      @keyframes lineFlow {
        from { stroke-dashoffset: 0; }
        to { stroke-dashoffset: -20; }
      }
    `;
    document.head.appendChild(style);

    function getNodeCenter(nodeEl: Element) {
      const scenarioNode = nodeEl.querySelector('.scenario-node');
      const rect = scenarioNode ? scenarioNode.getBoundingClientRect() : nodeEl.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        width: rect.width,
        height: rect.height
      };
    }

    function getEdgePoint(centerX: number, centerY: number, halfW: number, halfH: number, targetX: number, targetY: number) {
      const dx = targetX - centerX;
      const dy = targetY - centerY;

      let t = 1;
      if (dx !== 0) t = Math.min(t, halfW / Math.abs(dx));
      if (dy !== 0) t = Math.min(t, halfH / Math.abs(dy));

      return {
        x: centerX + dx * t,
        y: centerY + dy * t
      };
    }

    function updateLines() {
      const containerRect = container.getBoundingClientRect();
      const hubRect = hubCenter.getBoundingClientRect();
      const hubCenterX = hubRect.left + hubRect.width / 2;
      const hubCenterY = hubRect.top + hubRect.height / 2;
      const hubHalfW = hubRect.width / 2 * 0.75;
      const hubHalfH = hubRect.height / 2 * 0.75;

      nodes.forEach((node, index) => {
        const nodeInfo = getNodeCenter(node);

        // Point sur le bord du node vers le hub
        const nodeEdge = getEdgePoint(
          nodeInfo.x, nodeInfo.y,
          nodeInfo.width / 2, nodeInfo.height / 2,
          hubCenterX, hubCenterY
        );

        // Point sur le bord du hub vers le node
        const hubEdge = getEdgePoint(
          hubCenterX, hubCenterY,
          hubHalfW, hubHalfH,
          nodeInfo.x, nodeInfo.y
        );

        const x1 = hubEdge.x - containerRect.left;
        const y1 = hubEdge.y - containerRect.top;
        const x2 = nodeEdge.x - containerRect.left;
        const y2 = nodeEdge.y - containerRect.top;

        lines[index].setAttribute('x1', String(x1));
        lines[index].setAttribute('y1', String(y1));
        lines[index].setAttribute('x2', String(x2));
        lines[index].setAttribute('y2', String(y2));
      });
    }

    // Hover effect
    nodes.forEach((node, index) => {
      node.addEventListener('mouseenter', () => {
        lines[index].setAttribute('stroke-width', '3');
      });
      node.addEventListener('mouseleave', () => {
        lines[index].setAttribute('stroke-width', '2');
      });
    });

    // Initial update
    updateLines();
    window.addEventListener('resize', updateLines);

    // ========================================
    // ACTIVATION DU FLOTTEMENT APRÈS APPARITION
    // ========================================
    nodes.forEach((node) => {
      const appearDelay = parseFloat(getComputedStyle(node).getPropertyValue('--appear-delay')) || 0.3;
      const floatStartTime = (appearDelay + 0.6) * 1000;

      setTimeout(() => {
        node.classList.add('floating');
      }, floatStartTime);
    });

    // Mettre à jour les lignes avec requestAnimationFrame (sans throttle pour fluidité)
    function updateLinesLoop() {
      updateLines();
      requestAnimationFrame(updateLinesLoop);
    }
    requestAnimationFrame(updateLinesLoop);
  });
</script>
