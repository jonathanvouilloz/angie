---
// Section Hero avec design hub-and-spoke géométrique futuriste
// Grille CSS 5×3 symétrique avec animations de flottement
// PAS de drag & drop - structure fixe et propre

import ScenarioNode from './ScenarioNode.astro';
import { scenarios } from '../../data/scenarios';
import logoSvg from '../../assets/logo.svg';
---

<section class="hero-hub">
  <!-- Canvas pour les particules -->
  <canvas class="particles-canvas" id="particles-canvas"></canvas>

  <!-- Fond géométrique -->
  <div class="hero-bg">
    <div class="grid-pattern"></div>
    <div class="gradient-overlay"></div>
  </div>

  <!-- Contenu -->
  <div class="hero-content">
    <!-- Titre -->
    <header class="hero-header">
      <h1 class="hero-title">
        Quelle est ta
        <span class="title-highlight">situation</span> ?
      </h1>
      <p class="hero-subtitle">
        Clique sur ce qui te parle pour découvrir la solution.
      </p>
    </header>

    <!-- Hub and Spoke Layout - Grille 5×3 -->
    <div class="hub-container" id="hub-container">
      <!-- Lignes SVG dynamiques -->
      <svg class="connection-lines" id="connection-lines">
        <defs>
          <linearGradient id="line-grad-auto" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#00D9A3" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#00D9A3" stop-opacity="0.3"/>
          </linearGradient>
          <linearGradient id="line-grad-app" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#A300D9" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#A300D9" stop-opacity="0.3"/>
          </linearGradient>
          <linearGradient id="line-grad-web" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="#0096FF" stop-opacity="0.9"/>
            <stop offset="100%" stop-color="#0096FF" stop-opacity="0.3"/>
          </linearGradient>
          <filter id="glow-line">
            <feGaussianBlur stdDeviation="1.5" result="blur"/>
            <feMerge>
              <feMergeNode in="blur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>
      </svg>

      <!-- Grille des éléments - 7 colonnes pour meilleur espacement -->
      <div class="grid-layout">
        <!-- Ligne 1: 2 cards aux extrémités -->
        <div class="node-wrapper" data-node-index="0" data-service={scenarios[0].service} style="--appear-delay: 0.3s; --float-delay: 0s;">
          <ScenarioNode title={scenarios[0].title} subtitle={scenarios[0].subtitle} scenarioId={scenarios[0].id} service={scenarios[0].service} position={0} />
        </div>
        <div class="grid-spacer"></div>
        <div class="grid-spacer"></div>
        <div class="grid-spacer"></div>
        <div class="grid-spacer"></div>
        <div class="grid-spacer"></div>
        <div class="node-wrapper" data-node-index="1" data-service={scenarios[1].service} style="--appear-delay: 0.4s; --float-delay: 0.5s;">
          <ScenarioNode title={scenarios[1].title} subtitle={scenarios[1].subtitle} scenarioId={scenarios[1].id} service={scenarios[1].service} position={1} />
        </div>

        <!-- Ligne 2: 2 cards + HUB central -->
        <div class="node-wrapper" data-node-index="2" data-service={scenarios[2].service} style="--appear-delay: 0.5s; --float-delay: 1s;">
          <ScenarioNode title={scenarios[2].title} subtitle={scenarios[2].subtitle} scenarioId={scenarios[2].id} service={scenarios[2].service} position={2} />
        </div>
        <div class="grid-spacer"></div>
        <div class="grid-spacer"></div>

        <!-- Hub central (colonne 4 sur 7) -->
        <div class="hub-center" id="hub-center">
          <div class="hub-frame">
            <span class="hub-corner hub-corner-tl"></span>
            <span class="hub-corner hub-corner-tr"></span>
            <span class="hub-corner hub-corner-bl"></span>
            <span class="hub-corner hub-corner-br"></span>
          </div>
          <div class="hub-inner">
            <div class="hub-logo">
              <img src={logoSvg.src} alt="Jon Labs" />
            </div>
          </div>
          <div class="hub-pulse"></div>
        </div>

        <div class="grid-spacer"></div>
        <div class="grid-spacer"></div>
        <div class="node-wrapper" data-node-index="3" data-service={scenarios[3].service} style="--appear-delay: 0.6s; --float-delay: 1.5s;">
          <ScenarioNode title={scenarios[3].title} subtitle={scenarios[3].subtitle} scenarioId={scenarios[3].id} service={scenarios[3].service} position={3} />
        </div>

        <!-- Ligne 3: 4 cards espacées (colonnes 1, 3, 5, 7) -->
        <div class="node-wrapper" data-node-index="4" data-service={scenarios[4].service} style="--appear-delay: 0.7s; --float-delay: 2s;">
          <ScenarioNode title={scenarios[4].title} subtitle={scenarios[4].subtitle} scenarioId={scenarios[4].id} service={scenarios[4].service} position={4} />
        </div>
        <div class="grid-spacer"></div>
        <div class="node-wrapper" data-node-index="5" data-service={scenarios[5].service} style="--appear-delay: 0.8s; --float-delay: 2.5s;">
          <ScenarioNode title={scenarios[5].title} subtitle={scenarios[5].subtitle} scenarioId={scenarios[5].id} service={scenarios[5].service} position={5} />
        </div>
        <div class="grid-spacer"></div>
        <div class="node-wrapper" data-node-index="6" data-service={scenarios[6].service} style="--appear-delay: 0.9s; --float-delay: 3s;">
          <ScenarioNode title={scenarios[6].title} subtitle={scenarios[6].subtitle} scenarioId={scenarios[6].id} service={scenarios[6].service} position={6} />
        </div>
        <div class="grid-spacer"></div>
        <div class="node-wrapper" data-node-index="7" data-service={scenarios[7].service} style="--appear-delay: 1s; --float-delay: 3.5s;">
          <ScenarioNode title={scenarios[7].title} subtitle={scenarios[7].subtitle} scenarioId={scenarios[7].id} service={scenarios[7].service} position={7} />
        </div>
      </div>
    </div>

    <!-- Scroll indicator -->
    <div class="scroll-indicator">
      <span>Voir les détails</span>
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 5v14M19 12l-7 7-7-7"/>
      </svg>
    </div>
  </div>
</section>

<style>
  .hero-hub {
    min-height: 100vh;
    min-height: 100dvh;
    position: relative;
    overflow: hidden;
    background: #0a0a0f;
  }

  /* Canvas particules */
  .particles-canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    pointer-events: none;
    opacity: 0.6;
  }

  /* Fond géométrique */
  .hero-bg {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .grid-pattern {
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
    background-size: 50px 50px;
    mask-image: radial-gradient(ellipse at center, black 30%, transparent 80%);
  }

  .gradient-overlay {
    position: absolute;
    inset: 0;
    background:
      radial-gradient(circle at 30% 20%, rgba(0, 217, 163, 0.06) 0%, transparent 40%),
      radial-gradient(circle at 70% 80%, rgba(163, 0, 217, 0.06) 0%, transparent 40%),
      radial-gradient(circle at 50% 50%, rgba(0, 150, 255, 0.04) 0%, transparent 50%);
  }

  /* Contenu */
  .hero-content {
    position: relative;
    z-index: 1;
    min-height: 100vh;
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem 1rem;
  }

  /* Header */
  .hero-header {
    text-align: center;
    margin-bottom: 1.5rem;
    padding-top: 2rem;
  }

  .hero-title {
    font-size: clamp(1.5rem, 3.5vw, 2.25rem);
    font-weight: 400;
    color: white;
    line-height: 1.2;
    margin: 0 0 0.5rem;
    letter-spacing: -0.02em;
  }

  .title-highlight {
    position: relative;
    color: #00D9A3;
  }

  .title-highlight::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: -2px;
    height: 2px;
    background: linear-gradient(90deg, transparent, #00D9A3, transparent);
  }

  .hero-subtitle {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.5);
    margin: 0;
  }

  /* Hub Container */
  .hub-container {
    position: relative;
    flex: 1;
    width: 100%;
    max-width: 1200px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Grille CSS 7×3 pour meilleur espacement */
  .grid-layout {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    grid-template-rows: 1fr 1fr 1fr;
    gap: 0.75rem;
    width: 100%;
    height: 100%;
    min-height: 450px;
    place-items: center;
  }

  .grid-spacer {
    /* Cellules vides */
  }

  /* Connection lines SVG */
  .connection-lines {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: visible;
    opacity: 0;
    animation: linesReveal 0.5s ease-out 0.4s forwards;
  }

  @keyframes linesReveal {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .connection-lines line {
    stroke-width: 2;
    stroke-dasharray: 6 4;
    filter: url(#glow-line);
  }

  /* Hub center */
  .hub-center {
    position: relative;
    width: 140px;
    height: 140px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    animation: hubReveal 0.6s ease-out 0.2s forwards;
  }

  @keyframes hubReveal {
    from {
      opacity: 0;
      transform: scale(0.6);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  .hub-frame {
    position: absolute;
    inset: 0;
    border: 1px solid rgba(255, 255, 255, 0.15);
  }

  .hub-corner {
    position: absolute;
    width: 20px;
    height: 20px;
    border-color: #00D9A3;
    border-style: solid;
  }

  .hub-corner-tl { top: -1px; left: -1px; border-width: 2px 0 0 2px; }
  .hub-corner-tr { top: -1px; right: -1px; border-width: 2px 2px 0 0; }
  .hub-corner-bl { bottom: -1px; left: -1px; border-width: 0 0 2px 2px; }
  .hub-corner-br { bottom: -1px; right: -1px; border-width: 0 2px 2px 0; }

  .hub-inner {
    position: relative;
    width: 110px;
    height: 110px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .hub-logo {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .hub-logo img {
    width: 90px;
    height: auto;
    filter: brightness(0) invert(1);
  }

  .hub-pulse {
    position: absolute;
    inset: -10px;
    border: 1px solid rgba(0, 217, 163, 0.3);
    animation: hubPulse 3s ease-in-out infinite;
  }

  @keyframes hubPulse {
    0%, 100% { opacity: 0.3; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.05); }
  }

  /* Node wrapper - apparition uniquement */
  .node-wrapper {
    opacity: 0;
    transform: translateY(20px);
    will-change: transform, opacity;
    animation: nodeAppear 0.5s ease-out forwards;
    animation-delay: var(--appear-delay, 0.3s);
  }

  /* Float ajouté par JS après apparition */
  .node-wrapper.floating {
    opacity: 1;
    transform: translateY(0);
    animation: nodeFloat 4s ease-in-out infinite;
    animation-delay: var(--float-delay, 0s);
  }

  @keyframes nodeAppear {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes nodeFloat {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
  }

  /* Scroll indicator */
  .scroll-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.4);
    font-size: 0.8rem;
    padding: 0.75rem;
    animation: bounce 2.5s infinite;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(5px); }
  }

  /* Responsive - Mobile */
  @media (max-width: 900px) {
    .hero-hub {
      min-height: auto;
    }

    .particles-canvas {
      display: none;
    }

    .hero-content {
      min-height: auto;
      padding: 3rem 1rem 2rem;
    }

    .hero-header {
      padding-top: 0;
    }

    .hub-container {
      min-height: auto;
    }

    .grid-layout {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      min-height: auto;
    }

    .grid-spacer {
      display: none;
    }

    .connection-lines {
      display: none;
    }

    .hub-center {
      width: 100px;
      height: 100px;
      margin-bottom: 1rem;
    }

    .hub-inner {
      width: 80px;
      height: 80px;
    }

    .hub-logo img {
      width: 65px;
    }

    .hub-corner {
      width: 15px;
      height: 15px;
    }

    .node-wrapper {
      width: 100%;
      max-width: 300px;
    }

    /* Pas de flottement sur mobile */
    .node-wrapper.floating {
      animation: none;
    }
  }

  /* Large screens */
  @media (min-width: 1400px) {
    .hub-center {
      width: 170px;
      height: 170px;
    }

    .hub-inner {
      width: 135px;
      height: 135px;
    }

    .hub-logo img {
      width: 110px;
    }

    .hub-corner {
      width: 25px;
      height: 25px;
    }
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('hub-container');
    const svg = document.getElementById('connection-lines');
    const hubCenter = document.getElementById('hub-center');
    const nodes = document.querySelectorAll('.node-wrapper');
    const particlesCanvas = document.getElementById('particles-canvas') as HTMLCanvasElement;

    if (!container || !svg || !hubCenter) return;

    // ========================================
    // SYSTÈME DE PARTICULES
    // ========================================
    if (particlesCanvas && window.innerWidth > 768) {
      const ctx = particlesCanvas.getContext('2d');
      if (ctx) {
        const PARTICLE_COUNT = 30;
        const CONNECTION_DISTANCE = 100;
        const PARTICLE_SPEED = 0.3;

        const COLORS = [
          { r: 0, g: 217, b: 163 },
          { r: 163, g: 0, b: 217 },
          { r: 0, g: 150, b: 255 }
        ];

        interface Particle {
          x: number;
          y: number;
          vx: number;
          vy: number;
          size: number;
          color: { r: number; g: number; b: number };
        }

        const particles: Particle[] = [];

        function resizeCanvas() {
          particlesCanvas.width = window.innerWidth;
          particlesCanvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        for (let i = 0; i < PARTICLE_COUNT; i++) {
          particles.push({
            x: Math.random() * particlesCanvas.width,
            y: Math.random() * particlesCanvas.height,
            vx: (Math.random() - 0.5) * PARTICLE_SPEED * 2,
            vy: (Math.random() - 0.5) * PARTICLE_SPEED * 2,
            size: 1.5 + Math.random() * 1.5,
            color: COLORS[i % 3]
          });
        }

        function animateParticles() {
          ctx!.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);

          particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0 || p.x > particlesCanvas.width) p.vx *= -1;
            if (p.y < 0 || p.y > particlesCanvas.height) p.vy *= -1;

            ctx!.beginPath();
            ctx!.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx!.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0.6)`;
            ctx!.fill();

            for (let j = i + 1; j < particles.length; j++) {
              const other = particles[j];
              const dx = p.x - other.x;
              const dy = p.y - other.y;
              const distance = Math.sqrt(dx * dx + dy * dy);

              if (distance < CONNECTION_DISTANCE) {
                const opacity = (1 - distance / CONNECTION_DISTANCE) * 0.3;
                const avgR = Math.round((p.color.r + other.color.r) / 2);
                const avgG = Math.round((p.color.g + other.color.g) / 2);
                const avgB = Math.round((p.color.b + other.color.b) / 2);

                ctx!.beginPath();
                ctx!.moveTo(p.x, p.y);
                ctx!.lineTo(other.x, other.y);
                ctx!.strokeStyle = `rgba(${avgR}, ${avgG}, ${avgB}, ${opacity})`;
                ctx!.lineWidth = 1;
                ctx!.stroke();
              }
            }
          });

          requestAnimationFrame(animateParticles);
        }

        setTimeout(animateParticles, 100);
      }
    }

    // ========================================
    // LIGNES DE CONNEXION
    // ========================================
    const gradients: Record<string, string> = {
      'automatisation': 'url(#line-grad-auto)',
      'applications': 'url(#line-grad-app)',
      'dev-web': 'url(#line-grad-web)'
    };

    const lines: SVGLineElement[] = [];
    nodes.forEach((node, index) => {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      const service = node.getAttribute('data-service') || 'automatisation';
      line.setAttribute('stroke', gradients[service]);
      line.setAttribute('stroke-width', '2');
      line.setAttribute('stroke-dasharray', '6 4');
      line.setAttribute('filter', 'url(#glow-line)');
      line.style.animation = `lineFlow 1.8s linear infinite`;
      line.style.animationDelay = `${index * 0.15}s`;
      svg.appendChild(line);
      lines.push(line);
    });

    const style = document.createElement('style');
    style.textContent = `
      @keyframes lineFlow {
        from { stroke-dashoffset: 0; }
        to { stroke-dashoffset: -20; }
      }
    `;
    document.head.appendChild(style);

    function getNodeCenter(nodeEl: Element) {
      const scenarioNode = nodeEl.querySelector('.scenario-node');
      const rect = scenarioNode ? scenarioNode.getBoundingClientRect() : nodeEl.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2,
        width: rect.width,
        height: rect.height
      };
    }

    function getEdgePoint(centerX: number, centerY: number, halfW: number, halfH: number, targetX: number, targetY: number) {
      const dx = targetX - centerX;
      const dy = targetY - centerY;

      let t = 1;
      if (dx !== 0) t = Math.min(t, halfW / Math.abs(dx));
      if (dy !== 0) t = Math.min(t, halfH / Math.abs(dy));

      return {
        x: centerX + dx * t,
        y: centerY + dy * t
      };
    }

    function updateLines() {
      const containerRect = container.getBoundingClientRect();
      const hubRect = hubCenter.getBoundingClientRect();
      const hubCenterX = hubRect.left + hubRect.width / 2;
      const hubCenterY = hubRect.top + hubRect.height / 2;
      const hubHalfW = hubRect.width / 2 * 0.75;
      const hubHalfH = hubRect.height / 2 * 0.75;

      nodes.forEach((node, index) => {
        const nodeInfo = getNodeCenter(node);

        // Point sur le bord du node vers le hub
        const nodeEdge = getEdgePoint(
          nodeInfo.x, nodeInfo.y,
          nodeInfo.width / 2, nodeInfo.height / 2,
          hubCenterX, hubCenterY
        );

        // Point sur le bord du hub vers le node
        const hubEdge = getEdgePoint(
          hubCenterX, hubCenterY,
          hubHalfW, hubHalfH,
          nodeInfo.x, nodeInfo.y
        );

        const x1 = hubEdge.x - containerRect.left;
        const y1 = hubEdge.y - containerRect.top;
        const x2 = nodeEdge.x - containerRect.left;
        const y2 = nodeEdge.y - containerRect.top;

        lines[index].setAttribute('x1', String(x1));
        lines[index].setAttribute('y1', String(y1));
        lines[index].setAttribute('x2', String(x2));
        lines[index].setAttribute('y2', String(y2));
      });
    }

    // Hover effect
    nodes.forEach((node, index) => {
      node.addEventListener('mouseenter', () => {
        lines[index].setAttribute('stroke-width', '3');
      });
      node.addEventListener('mouseleave', () => {
        lines[index].setAttribute('stroke-width', '2');
      });
    });

    // Initial update
    updateLines();
    window.addEventListener('resize', updateLines);

    // ========================================
    // ACTIVATION DU FLOTTEMENT APRÈS APPARITION
    // ========================================
    nodes.forEach((node) => {
      const appearDelay = parseFloat(getComputedStyle(node).getPropertyValue('--appear-delay')) || 0.3;
      // Attendre la fin de l'animation d'apparition (délai + 0.5s durée)
      const floatStartTime = (appearDelay + 0.6) * 1000;

      setTimeout(() => {
        node.classList.add('floating');
      }, floatStartTime);
    });

    // Mettre à jour les lignes avec requestAnimationFrame (plus fluide)
    let lastUpdate = 0;
    function updateLinesLoop(timestamp: number) {
      if (timestamp - lastUpdate > 50) { // ~20fps pour les lignes
        updateLines();
        lastUpdate = timestamp;
      }
      requestAnimationFrame(updateLinesLoop);
    }
    requestAnimationFrame(updateLinesLoop);
  });
</script>
